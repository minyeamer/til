# Algorithm Study
1. defaultdict()
2. infinite
3. Prim's Algorithm
4. struggling with a problem

## 1. defaultdict()
- collections 모듈에 포함된 dict의 서브 클래스
- dict와 작동 방식은 동일하지만 인자로 주어진 객체의 기본값을 초기값으로 지정 가능
```python
>>> int_dict = defaultdict(int)
>>> int_dict
>>> defaultdict(<class 'int'>, {})
```
- int를 인자로 넣을 경우 값을 지정하지 않은 키는 그 값이 0으로 지정됨
```python
>>> int_dict['key1']
0
>>> int_dict
defaultdict(<class 'int'>, {'key': 0})
```

## 2. infinite
- 양의 무한대 ```float('inf')```
- 음의 무한대 ```float('-inf')```

## 3. Prim's Algorithm
- 시작 정점을 선택한 후, 정점에 인접한 간선 중 최소 비용의 간선을 연결하여   
최소 신장 트리(MST)를 확장해가는 방식
- **Kruskal's Algorithm**이 **비용이 가장 작은 간선부터** 다음 간선을 선택하는데 반해,   
**Prim's Algorithm**은 **특정 정점에서부터** 다음 정점을 갱신해나가며 비용이 작은 간선을 선택
- Prim's Algorithm의 시간 복잡도는 최악의 경우 **O(E log E**)   
(while 구문에서 모든 간선에 대해 반복하고, 최소 힙 구조를 사용)
- Reference: https://www.fun-coding.org/Chapter20-prim-live.html
#### 파이썬 구현 코드
```python
def prim(edge_list: list, start_node: int) -> list:
    mst = list()
    adjacent_edge_list = defaultdict(list)
    for weight, n1, n2 in edge_list:
        adjacent_edge_list[n1].append((weight, n1, n2))
        adjacent_edge_list[n1].append((weight, n2, n1))

    connected_nodes = {start_node}
    candidate_edge_list = adjacent_edge_list[start_node]
    heapq.heapify(candidate_edge_list)

    while candidate_edge_list:
        weight, n1, n2 = heapq.heappop(candidate_edge_list)
        if n2 not in connected_nodes:
            connected_nodes.add(n2)
            mst.append((weight, n1, n2))

            for edge in adjacent_edge_list[n2]:
                if edge[2] not in connected_nodes:
                    heapq.heappush(candidate_edge_list, edge)

    return mst
```

### Prim's Algorithm 개선
- 간선이 아닌 **노드를 중심**으로 우선순위 큐를 적용
- 노드마다 Key 값을 가지고 있고, Key 값을 우선순위 큐에 넣음
- Key 값이 0인 정점의 인접한 정점들에 대해 Key 값과 연결된 비용을 비교하여   
  Key 값이 작으면 해당 정점의 Key 값을 갱신
- 개선된 Prim's Algorithm의 시간 복잡도는 **O(E log V**)
- 해당 알고리즘을 구현하기 위해 heapdict 라이브러리 사용   
  (기존의 heap 내용을 업데이트하면 알아서 최소 힙의 구조로 업데이트됨)
#### 파이썬 구현 코드
```python
from heapdict import heapdict

def prim(graph: dict, start_node: int) -> (list, int):
    mst, keys, pi, total_weight = list(), heapdict(), dict(), 0

    for node in graph.keys():
        keys[node] = float('inf')
        pi[node] = None
    keys[start_node], pi[start_node] = 0, start_node

    while keys:
        current_node, current_key = keys.popitem()
        mst.append([pi[current_node], current_node, current_key])
        total_weight += current_key

        for adjacent, weight in graph[current_node].items():
            if adjacent in keys and weight < keys[adjacent]:
                keys[adjacent] = weight
                pi[adjacent] = current_node

    return mst, total_weight
```

## 4. struggling with a problem
- 백준 골드 5를 혼자서 푼 후 기고만장해져서 골드 4의 1197번 문제에 도전해보았다.
- 이틀에 걸쳐 도전했지만 포기하고 정답을 보게되었음에도 문제를 해결한 것 같지 않다.
- 해당 문제는 n개의 정점들에 대한 간선들 중에서 가장 가중치가 작은 길의 가중치를 찾는 것이다.
1. 처음엔 노드하면 DFS와 BFS 밖에 몰랐기 때문에 당연하게 DFS로 접근했다:   
>- 먼저 부모, 자식, 가중치, 인덱스를 변수로 가지는 Node 클래스를 선언하여   
간선의 정보를 노드 내 인스턴스 변수에 저장하게 한다.
>- 전체 노드 중 자식 노드를 가진 노드에 한해 가중치 최솟값을 구하는 함수를 실행한다.
>- 해당 함수는 root에서부터 end-point까지 순회하면서 가중치 합의 최솟값을 구한다.
>- 함수의 결과는 따로 반환되지 않고 root 노드의 인스턴스 변수에 저장된다.
>- 이러한 논리를 가지고 작성한 알고리즘이 아래 코드이다.
>- 하지만 해당 코드는 1초의 시간 제한 안에 돌아가기엔 무리가 있었다.
<details>
<summary>First Code</summary>
<div markdown="1">
<pre class="python"><code>
class Node:
    def __init__(self, index):
        self.index = index
        self.data = 2147483647
        self.parent = []
        self.child = []

    def print_node(self):
        print(self.index, self.data, self.parent, self.child)

def spanning_tree(nodes, check, root, parent, data):
    for child in parent.child:
        weight = data + child[1]
        child = nodes[child[0]]
        if child.child:
            if not check[child.index]:
                spanning_tree(nodes, check, root, child, weight)
        else:
            check[parent.index] = True
            if weight < root.data:
                root.data = weight

V, E = map(int, input().split())
graph = [Node(i) for i in range(V+1)]
visited = [False for _ in range(V+1)]

for _ in range(E):
    A, B, C = map(int, input().split())
    graph[A].child.append((B,C))
    graph[B].parent.append((A,C))

min_weight = 2147483647

for node in graph:
    if node.child and not node.parent:
        spanning_tree(graph, visited, node, node, 0)
        if node.data < min_weight:
            min_weight = node.data

print(min_weight)
</code></pre>
</div>
</details>
<!--==================================================================== 코드 1 끝-->
2. Kruskal's Algorithm:
>- 작성 중
> ...

<!--==================================================================== 코드 2 시작-->
<details>
<summary>Second Code</summary>
<div markdown="1">
<pre class="python"><code>
class Node:
    def __init__(self, index):
        self.index = index
        self.data = 0
        self.root = self
        self.parent = self
        self.active = None
        self.passive = []

    def get_branch(self):
        if self.active:
            return self.passive + [self.active]
        else:
            return []

    def set_branch(self, node, data):
        if self.root == node.root:
            if data < node.data:
                node.parent = self
                node.data = data
        else:
            node.root = self.root
            node.parent = self
            node.data += data
        if not self.active:
            self.active = node
            self.data += node.data
            node.data = self.data
        else:
            self.passive.append(node)
        self.update_data()

    def update_data(self):
        branch = self.get_branch()
        branch.sort(key=lambda n: n.data, reverse=True)
        active = branch.pop()
        if active != self.active:
            self.active = active
            self.passive = branch
        self.data = self.active.data

def union_root(source: Node, target: Node, data: int) -> None:
    root = source.root
    if target.root in [source, source.root, target]:
        source.set_branch(target, data)
        while source != root:
            source = source.parent
            source.update_data()


V, E = map(int, input().split())

graph = [Node(i) for i in range(V + 1)]
edge_dict = {}

for _ in range(E):
    A, B, C = map(int, input().split())
    edge_dict[(A, B)] = C

edge_list = sorted(edge_dict.items(), key=lambda x: [x[1], x[0]])

for (a, b), c in edge_list:
    node_a, node_b = graph[a], graph[b]
    if node_a.parent != node_b.parent:
        union_root(node_a, node_b, c)

weight = 2147483647

for edge_node in graph:
    if (edge_node.root == edge_node) and edge_node.get_branch():
        if edge_node.data < weight:
            weight = edge_node.data

print(weight)
</code></pre>
</div>
</details>
<!--==================================================================== 코드 2 끝-->
3. Prim's Algorithm:
>- 작성 중
>
<!--==================================================================== 코드 3 시작-->
<details>
<summary>Third Code</summary>
<div markdown="1">
<pre class="python"><code>
def prim(nodes: dict, start: int) -> int or float:
    mst, keys, pi = [], heapdict(), dict()
    depth, total_weight = -1, 0

    for n in nodes.keys():
        keys[n] = float('inf')
        pi[n] = None
    keys[start], pi[start] = 0, start

    while keys:
        current_node, current_key = keys.popitem()
        current_depth = get_depth(pi, start, current_node, 0)
        if current_depth <= depth:
            if pi[current_node] == start:
                return float('inf')
            break
        depth = current_depth
        mst.append([pi[current_node], current_node, current_key])
        total_weight += current_key

        for adjacent, weight in nodes[current_node].items():
            if adjacent in keys and weight < keys[adjacent]:
                keys[adjacent] = weight
                pi[adjacent] = current_node

    return total_weight

def get_depth(nodes: dict, root: int, start: int, data: int) -> int:
    if start == root:
        return data
    if nodes[start] == root:
        return data+1
    return get_depth(nodes, root, nodes[start], data+1)


V, E = map(int, input().split())
graph = defaultdict(dict)

for _ in range(E):
    A, B, C = map(int, input().split())
    graph[A][B] = C
    graph[B][A] = C

weight_list = []
for node in graph.keys():
    heapq.heappush(weight_list, prim(graph, node))

print(heapq.heappop(weight_list))
</code></pre>
</div>
</details>
<!--==================================================================== 코드 3 끝-->
4. 결론:
>- 작성 중
>

#### Userful Reference
Graph Editor: https://csacademy.com/app/graph_editor/
